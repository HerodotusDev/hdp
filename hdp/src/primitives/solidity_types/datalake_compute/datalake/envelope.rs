use crate::{
    primitives::solidity_types::traits::{Codecs, DatalakeCodecs},
    primitives::task::datalake::{
        block_sampled::BlockSampledDatalake, datalake_type::DatalakeType,
        envelope::DatalakeEnvelope, transactions::TransactionsInBlockDatalake,
    },
    primitives::utils::last_byte_to_u8,
};
use alloy::{
    dyn_abi::{DynSolType, DynSolValue},
    primitives::B256,
};
use anyhow::Result;

pub type BatchedDatalakeEnvelope = Vec<DatalakeEnvelope>;

impl Codecs for BatchedDatalakeEnvelope {
    fn encode(&self) -> Result<Vec<u8>> {
        let mut encoded_datalakes: Vec<DynSolValue> = Vec::new();

        for datalake in self {
            let encoded_datalake = match datalake {
                DatalakeEnvelope::BlockSampled(block_sampled_datalake) => {
                    block_sampled_datalake.encode()?
                }
                DatalakeEnvelope::TransactionsInBlock(transactions_datalake) => {
                    transactions_datalake.encode()?
                }
            };
            encoded_datalakes.push(DynSolValue::Bytes(encoded_datalake));
        }

        let array_encoded_datalakes = DynSolValue::Array(encoded_datalakes);
        let encoded_datalakes = array_encoded_datalakes.abi_encode();
        Ok(encoded_datalakes)
    }

    fn decode(encoded: &[u8]) -> Result<Vec<DatalakeEnvelope>> {
        let datalakes_type: DynSolType = "bytes[]".parse()?;
        let serialized_datalakes = datalakes_type.abi_decode(encoded)?;

        let mut decoded_datalakes = Vec::new();

        if let Some(datalakes) = serialized_datalakes.as_array() {
            for datalake in datalakes {
                let datalake_as_bytes =
                    datalake.as_bytes().expect("Cannot get bytes from datalake");
                decoded_datalakes.push(DatalakeEnvelope::decode(datalake_as_bytes)?);
            }
        }

        Ok(decoded_datalakes)
    }
}

impl DatalakeCodecs for DatalakeEnvelope {
    fn decode(encoded_datalake: &[u8]) -> Result<Self> {
        let datalake_code = last_byte_to_u8(encoded_datalake.chunks(32).next().unwrap());
        let decoded_datalake = match DatalakeType::from_index(datalake_code)? {
            DatalakeType::BlockSampled => {
                DatalakeEnvelope::BlockSampled(BlockSampledDatalake::decode(encoded_datalake)?)
            }
            DatalakeType::TransactionsInBlock => DatalakeEnvelope::TransactionsInBlock(
                TransactionsInBlockDatalake::decode(encoded_datalake)?,
            ),
        };
        Ok(decoded_datalake)
    }

    fn encode(&self) -> Result<Vec<u8>> {
        match self {
            DatalakeEnvelope::BlockSampled(datalake) => datalake.encode(),
            DatalakeEnvelope::TransactionsInBlock(datalake) => datalake.encode(),
        }
    }

    fn get_datalake_type(&self) -> DatalakeType {
        match self {
            DatalakeEnvelope::BlockSampled(_) => DatalakeType::BlockSampled,
            DatalakeEnvelope::TransactionsInBlock(_) => DatalakeType::TransactionsInBlock,
        }
    }

    fn commit(&self) -> B256 {
        match self {
            DatalakeEnvelope::BlockSampled(datalake) => datalake.commit(),
            DatalakeEnvelope::TransactionsInBlock(datalake) => datalake.commit(),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::primitives::{
        chain_id::ChainId,
        task::datalake::{
            block_sampled::{AccountField, BlockSampledCollection, BlockSampledDatalake},
            envelope::BatchedDatalakes,
            transactions::{
                IncludedTypes, TransactionField, TransactionReceiptField, TransactionsCollection,
                TransactionsInBlockDatalake,
            },
        },
    };
    use alloy::{hex, primitives::Address};
    use std::str::FromStr;

    use super::*;

    #[test]
    fn test_block_datalake_decoder_for_account() {
        let batched_block_datalake = hex::decode("0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000004b902400000000000000000000000000000000000000000000000000000000004b9027000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000016020a4de450feb156a2a51ed159b2fb99da26e5f3a30000000000000000000000").unwrap();
        let block_datalake = BlockSampledDatalake::new(
            ChainId::EthereumSepolia,
            4952100,
            4952103,
            1,
            "account.0x0a4de450feb156a2a51ed159b2fb99da26e5f3a3.nonce"
                .parse()
                .unwrap(),
        );

        let datalakes = vec![DatalakeEnvelope::BlockSampled(block_datalake.clone())];

        assert_eq!(datalakes.len(), 1);
        for datalake in datalakes.clone() {
            if let DatalakeEnvelope::BlockSampled(block_datalake) = datalake {
                assert_eq!(block_datalake.block_range_start, 4952100);
                assert_eq!(block_datalake.block_range_end, 4952103);
                assert_eq!(
                    block_datalake.sampled_property,
                    BlockSampledCollection::Account(
                        Address::from_str("0x0a4de450feb156a2a51ed159b2fb99da26e5f3a3").unwrap(),
                        AccountField::Nonce
                    )
                );
                assert_eq!(block_datalake.increment, 1);
            } else {
                panic!("Expected block datalake");
            }
        }

        assert_eq!(datalakes.encode().unwrap(), batched_block_datalake);
        assert_eq!(
            BatchedDatalakes::decode(&batched_block_datalake).unwrap(),
            datalakes
        );
    }

    #[test]
    fn test_block_massive_datalake_decoder() {
        let batched_block_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000003e0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000").unwrap();
        let datalake_massive_block = DatalakeEnvelope::BlockSampled(BlockSampledDatalake::new(
            ChainId::EthereumSepolia,
            10399000,
            10400000,
            1,
            "header.base_fee_per_gas".parse().unwrap(),
        ));

        let batched_datalakes = vec![
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
        ];

        let decoded_datalakes = BatchedDatalakes::decode(&batched_block_datalake).unwrap();
        assert_eq!(decoded_datalakes.len(), 4);

        assert_eq!(batched_datalakes.encode().unwrap(), batched_block_datalake);
    }

    #[test]
    fn test_transaction_datalakes_encoder() {
        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            ChainId::EthereumSepolia,
            100000,
            TransactionsCollection::Transactions(TransactionField::Nonce),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            ChainId::EthereumSepolia,
            100000,
            TransactionsCollection::Transactions(TransactionField::AccessList),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let datalakes = vec![
            DatalakeEnvelope::TransactionsInBlock(transaction_datalake1),
            DatalakeEnvelope::TransactionsInBlock(transaction_datalake2),
        ];
        let encoded_datalakes = datalakes.encode().unwrap();

        assert_eq!(encoded_datalakes, hex::decode("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000020100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000002010a000000000000000000000000000000000000000000000000000000000000").unwrap());
    }

    #[test]
    fn test_transaction_datalake_decoder() {
        let encoded_datalake = hex::decode("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000020100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000002010a000000000000000000000000000000000000000000000000000000000000").unwrap();
        let decoded_datalake = BatchedDatalakes::decode(&encoded_datalake).unwrap();
        assert_eq!(decoded_datalake.len(), 2);

        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            ChainId::EthereumSepolia,
            100000,
            TransactionsCollection::Transactions(TransactionField::Nonce),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            ChainId::EthereumSepolia,
            100000,
            TransactionsCollection::Transactions(TransactionField::AccessList),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        assert_eq!(
            decoded_datalake[0],
            DatalakeEnvelope::TransactionsInBlock(transaction_datalake1)
        );
        assert_eq!(
            decoded_datalake[1],
            DatalakeEnvelope::TransactionsInBlock(transaction_datalake2)
        );
    }

    #[test]
    fn test_transaction_datalakes_encoder_receipt() {
        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            ChainId::EthereumSepolia,
            100000,
            TransactionsCollection::TranasactionReceipts(TransactionReceiptField::Success),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            ChainId::EthereumSepolia,
            100000,
            TransactionsCollection::TranasactionReceipts(TransactionReceiptField::Bloom),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let datalakes = vec![
            DatalakeEnvelope::TransactionsInBlock(transaction_datalake1),
            DatalakeEnvelope::TransactionsInBlock(transaction_datalake2),
        ];
        let encoded_datalakes = datalakes.encode().unwrap();

        assert_eq!(encoded_datalakes, hex::decode("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000020200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000020203000000000000000000000000000000000000000000000000000000000000").unwrap())
    }

    #[test]
    fn test_transaction_datalake_decoder_receipt() {
        let encoded_datalake = hex::decode("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000020200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000aa36a700000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000020203000000000000000000000000000000000000000000000000000000000000").unwrap();
        let decoded_datalake = BatchedDatalakes::decode(&encoded_datalake).unwrap();
        assert_eq!(decoded_datalake.len(), 2);

        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            ChainId::EthereumSepolia,
            100000,
            TransactionsCollection::TranasactionReceipts(TransactionReceiptField::Success),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            ChainId::EthereumSepolia,
            100000,
            TransactionsCollection::TranasactionReceipts(TransactionReceiptField::Bloom),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        assert_eq!(
            decoded_datalake[0],
            DatalakeEnvelope::TransactionsInBlock(transaction_datalake1)
        );
        assert_eq!(
            decoded_datalake[1],
            DatalakeEnvelope::TransactionsInBlock(transaction_datalake2)
        );
    }
}
