use types::datalake::dynamic_layout_datalake::DynamicLayoutDatalake;

#[test]
fn test_dynamic_layout_datalake_serialized() {
    let datalake_bytes = b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9c\x1f\xbc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00{/\x05\xce\x9a\xe3e\xc3\xdb\xf3\x06W\xe2\xdcdI\x98\x9e\x83\xd6\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01";
    let decoded_datalake = DynamicLayoutDatalake::from_serialized(datalake_bytes).unwrap();
    let dynamic_layout_datalake = DynamicLayoutDatalake::new(
        10231740,
        "0x7b2f05cE9aE365c3DBF30657e2DC6449989e83D6".to_string(),
        5,
        0,
        3,
        1,
    );
    assert_eq!(decoded_datalake, dynamic_layout_datalake);
}
