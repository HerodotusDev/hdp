use decoder::args_decoder::{datalake_decoder, tasks_decoder, DatalakeType};

#[test]
fn test_task_decoder() {
    // Note: all task's datalake is None
    let decoded_tasks = tasks_decoder("0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000060617667000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006073756d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000606d696e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000606d6178000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000".to_string()).unwrap();
    assert_eq!(decoded_tasks.len(), 4);
    assert_eq!(decoded_tasks[0].aggregate_fn_id, "avg".to_string());
    assert_eq!(decoded_tasks[0].aggregate_fn_ctx, None);
    assert_eq!(decoded_tasks[1].aggregate_fn_id, "sum".to_string());
    assert_eq!(decoded_tasks[1].aggregate_fn_ctx, None);
    assert_eq!(decoded_tasks[2].aggregate_fn_id, "min".to_string());
    assert_eq!(decoded_tasks[2].aggregate_fn_ctx, None);
    assert_eq!(decoded_tasks[3].aggregate_fn_id, "max".to_string());
    assert_eq!(decoded_tasks[3].aggregate_fn_ctx, None);
}

#[test]
fn test_datalake_decoder() {
    let decoded_datalakes = datalake_decoder("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000".to_string()).unwrap();
    assert_eq!(decoded_datalakes.len(), 4);
    if let DatalakeType::Block(block_datalake) = &decoded_datalakes[0] {
        assert_eq!(block_datalake.block_range_start, 10399990);
        assert_eq!(block_datalake.block_range_end, 10400000);
        assert_eq!(
            block_datalake.sampled_property,
            "header.base_fee_per_gas".to_string()
        );
        assert_eq!(block_datalake.increment, 1);
    } else {
        panic!("Expected block datalake");
    }

    if let DatalakeType::Block(block_datalake) = &decoded_datalakes[1] {
        assert_eq!(block_datalake.block_range_start, 10399990);
        assert_eq!(block_datalake.block_range_end, 10400000);
        assert_eq!(
            block_datalake.sampled_property,
            "header.base_fee_per_gas".to_string()
        );
        assert_eq!(block_datalake.increment, 1);
    } else {
        panic!("Expected block datalake");
    }

    if let DatalakeType::Block(block_datalake) = &decoded_datalakes[2] {
        assert_eq!(block_datalake.block_range_start, 10399990);
        assert_eq!(block_datalake.block_range_end, 10400000);
        assert_eq!(
            block_datalake.sampled_property,
            "header.base_fee_per_gas".to_string()
        );
        assert_eq!(block_datalake.increment, 1);
    } else {
        panic!("Expected block datalake");
    }

    if let DatalakeType::Block(block_datalake) = &decoded_datalakes[3] {
        assert_eq!(block_datalake.block_range_start, 10399990);
        assert_eq!(block_datalake.block_range_end, 10400000);
        assert_eq!(
            block_datalake.sampled_property,
            "header.base_fee_per_gas".to_string()
        );
        assert_eq!(block_datalake.increment, 1);
    } else {
        panic!("Expected block datalake");
    }
}
