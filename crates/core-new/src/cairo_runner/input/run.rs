use cairo_lang_starknet_classes::casm_contract_class::CasmContractClass;
use hdp_primitives::datalake::output::{Task, TaskFormatted};
use hdp_provider::evm::AbstractProviderResult;
use serde::Serialize;
use serde_with::serde_as;
use starknet::core::serde::unsigned_field_element::UfeHex;
use starknet_crypto::FieldElement;

/*
    input.json file that will be passed to the processor, is generated by this struct.
*/

#[derive(Serialize)]
pub struct RunnerInput {
    /// Batched tasks root of all tasks.
    pub task_root: String,
    /// if every tasks are pre computable, this can be Some
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result_root: Option<String>,
    /// Fetched proofs per each fetch point.
    pub proofs: AbstractProviderResult,
    /// tasks compatible with v1
    pub datalakes: Vec<TaskFormatted>,
    /// tasks compatible with v2
    pub modules: Vec<InputModule>,
}

/// Input module for the runner.
#[serde_as]
#[derive(Serialize)]
pub struct InputModule {
    /// encoded module task
    pub encoded_task: String,
    /// Inputs of the module.
    #[serde_as(as = "Vec<UfeHex>")]
    inputs: Vec<FieldElement>,
    /// Detail class code of the module.
    /// This will be loaded to bootloader.
    module_class: CasmContractClass,
}

impl RunnerInput {
    pub fn new(proofs: AbstractProviderResult, datalakes: Vec<Task>) -> Self {
        Self {
            task_root: "".to_string(),
            result_root: None,
            modules: vec![],
            proofs,
            datalakes: datalakes.into_iter().map(|e| e.to_cairo_format()).collect(),
        }
    }

    pub fn add_module(&mut self, inputs: Vec<FieldElement>, module_class: CasmContractClass) {
        todo!("Add module to RunnerInput")
    }

    // TODO: Somehow need to make `Vec<CairoProgram>`, `Vec<Module>`, Vec<Proof> to input data format
    pub fn to_bytes(&self) -> Vec<u8> {
        todo!("Convert ProcessorInput to json")
    }
}
