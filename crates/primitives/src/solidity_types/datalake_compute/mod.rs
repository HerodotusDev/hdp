use alloy::{
    dyn_abi::DynSolValue,
    primitives::{keccak256, B256, U256},
};
use anyhow::Result;

use crate::{
    aggregate_fn::{integer::Operator, AggregationFunction},
    datalake::{compute::Computation, envelope::DatalakeEnvelope, DatalakeCompute},
};

use self::{compute::BatchedComputation, envelope::BatchedDatalakeEnvelope};

use super::traits::{BatchedDatalakeComputeCodecs, Codecs, DatalakeCodecs, DatalakeComputeCodecs};

pub mod block_sampled;
pub mod compute;
pub mod envelope;
pub mod transactions_in_block;

impl DatalakeComputeCodecs for DatalakeCompute {
    fn decode(serialized_datalake: &[u8], serialized_task: &[u8]) -> Result<DatalakeCompute> {
        let decoded_datalake = DatalakeEnvelope::decode(serialized_datalake)?;
        let decoded_compute = Computation::decode(serialized_task)?;
        Ok(DatalakeCompute::new(decoded_datalake, decoded_compute))
    }

    fn commit(&self) -> B256 {
        let encoded_datalake = self.encode().unwrap();
        keccak256(encoded_datalake)
    }

    fn encode(&self) -> Result<Vec<u8>> {
        let identifier_value = DynSolValue::FixedBytes(self.datalake.commit(), 32);

        let aggregate_fn_id = DynSolValue::Uint(
            U256::from(AggregationFunction::to_index(&self.compute.aggregate_fn_id)),
            8,
        );

        let operator = DynSolValue::Uint(
            U256::from(Operator::to_index(&self.compute.aggregate_fn_ctx.operator)),
            8,
        );
        let value_to_compare =
            DynSolValue::Uint(self.compute.aggregate_fn_ctx.value_to_compare, 32);

        let tuple_value = DynSolValue::Tuple(vec![
            identifier_value,
            aggregate_fn_id,
            operator,
            value_to_compare,
        ]);

        Ok(tuple_value.abi_encode())

        // match header_tuple_value.abi_encode_sequence() {
        //     Some(encoded) => Ok(bytes_to_hex_string(&encoded)),
        //     None => bail!("Failed to encode the task"),
        // }
    }
}

pub type BatchedDatalakeCompute = Vec<DatalakeCompute>;

impl BatchedDatalakeComputeCodecs for BatchedDatalakeCompute {
    fn decode(
        serialized_datalakes: &[u8],
        serialized_computes: &[u8],
    ) -> Result<Vec<DatalakeCompute>> {
        // decode datalakes and tasks
        let decoded_datalakes = BatchedDatalakeEnvelope::decode(serialized_datalakes)?;
        let decoded_computes = BatchedComputation::decode(serialized_computes)?;
        // check if the number of datalakes and tasks are the same
        if decoded_datalakes.len() != decoded_computes.len() {
            return Err(anyhow::anyhow!(
                "Number of datalakes and tasks are not the same"
            ));
        }

        // combine datalakes and tasks into DatalakeCompute
        let mut decoded_datalakes_compute = Vec::new();
        for (datalake, compute) in decoded_datalakes
            .into_iter()
            .zip(decoded_computes.into_iter())
        {
            decoded_datalakes_compute.push(DatalakeCompute::new(datalake, compute));
        }

        Ok(decoded_datalakes_compute)
    }
    fn encode(&self) -> Result<(Vec<u8>, Vec<u8>)> {
        let (datalakes, computes): (BatchedDatalakeEnvelope, BatchedComputation) = self
            .iter()
            .map(|datalake_compute| {
                (
                    datalake_compute.datalake.clone(),
                    datalake_compute.compute.clone(),
                )
            })
            .unzip();
        let encoded_datalakes = datalakes.encode()?;
        let encoded_computes = computes.encode()?;
        Ok((encoded_datalakes, encoded_computes))
    }

    fn commit(&self) -> B256 {
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use alloy::{hex, primitives::Address};

    use std::str::FromStr;

    use crate::{
        aggregate_fn::FunctionContext,
        datalake::{
            block_sampled::{
                AccountField, BlockSampledCollection, BlockSampledDatalake, HeaderField,
            },
            envelope::BatchedDatalakes,
            transactions::TransactionsInBlockDatalake,
        },
    };

    use super::*;

    #[test]
    fn test_compute_decoder() {
        // Note: all task's datalake is None
        let original_tasks: BatchedComputation = vec![
            Computation::new("avg", None),
            Computation::new("sum", None),
            Computation::new("min", None),
            Computation::new("max", None),
        ];

        let encoded_tasks = original_tasks.encode().unwrap();
        let decoded_tasks = BatchedComputation::decode(&encoded_tasks).unwrap();

        assert_eq!(decoded_tasks.len(), 4);
        assert_eq!(decoded_tasks[0].aggregate_fn_id, AggregationFunction::AVG);
        assert_eq!(
            decoded_tasks[0].aggregate_fn_ctx,
            FunctionContext::default()
        );

        assert_eq!(decoded_tasks[1].aggregate_fn_id, AggregationFunction::SUM);
        assert_eq!(
            decoded_tasks[1].aggregate_fn_ctx,
            FunctionContext::default()
        );

        assert_eq!(decoded_tasks[2].aggregate_fn_id, AggregationFunction::MIN);
        assert_eq!(
            decoded_tasks[2].aggregate_fn_ctx,
            FunctionContext::default()
        );

        assert_eq!(decoded_tasks[3].aggregate_fn_id, AggregationFunction::MAX);
        assert_eq!(
            decoded_tasks[3].aggregate_fn_ctx,
            FunctionContext::default()
        );
    }

    #[test]
    fn test_block_datalake_decoder() {
        let batched_block_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000").unwrap();
        let decoded_datalakes = BatchedDatalakes::decode(&batched_block_datalake).unwrap();

        assert_eq!(decoded_datalakes.len(), 4);
        for datalake in decoded_datalakes.clone() {
            if let DatalakeEnvelope::BlockSampled(block_datalake) = datalake {
                assert_eq!(block_datalake.block_range_start, 10399990);
                assert_eq!(block_datalake.block_range_end, 10400000);
                assert_eq!(
                    block_datalake.sampled_property,
                    BlockSampledCollection::Header(HeaderField::BaseFeePerGas)
                );
                assert_eq!(block_datalake.increment, 1);
            } else {
                panic!("Expected block datalake");
            }
        }

        assert_eq!(decoded_datalakes.encode().unwrap(), batched_block_datalake);
    }

    #[test]
    fn test_block_datalake_decoder_for_account() {
        let batched_block_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004b902400000000000000000000000000000000000000000000000000000000004b9027000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000016020a4de450feb156a2a51ed159b2fb99da26e5f3a30000000000000000000000").unwrap();
        let block_datalake = BlockSampledDatalake::new(
            4952100,
            4952103,
            "account.0x0a4de450feb156a2a51ed159b2fb99da26e5f3a3.nonce".to_string(),
            1,
        )
        .unwrap();
        let datalakes = vec![DatalakeEnvelope::BlockSampled(block_datalake.clone())];
        assert_eq!(datalakes.len(), 1);
        for datalake in datalakes.clone() {
            if let DatalakeEnvelope::BlockSampled(block_datalake) = datalake {
                assert_eq!(block_datalake.block_range_start, 4952100);
                assert_eq!(block_datalake.block_range_end, 4952103);
                assert_eq!(
                    block_datalake.sampled_property,
                    BlockSampledCollection::Account(
                        Address::from_str("0x0a4de450feb156a2a51ed159b2fb99da26e5f3a3").unwrap(),
                        AccountField::Nonce
                    )
                );
                assert_eq!(block_datalake.increment, 1);
            } else {
                panic!("Expected block datalake");
            }
        }

        assert_eq!(datalakes.encode().unwrap(), batched_block_datalake);
        assert_eq!(
            BatchedDatalakes::decode(&batched_block_datalake).unwrap(),
            datalakes
        );
    }

    #[test]
    fn test_block_massive_datalake_decoder() {
        let batched_block_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000").unwrap();
        let datalake_massive_block = DatalakeEnvelope::BlockSampled(
            BlockSampledDatalake::new(10399000, 10400000, "header.base_fee_per_gas".to_string(), 1)
                .unwrap(),
        );

        let batched_datalakes = vec![
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
        ];
        let decoded_datalakes = BatchedDatalakes::decode(&batched_block_datalake).unwrap();
        assert_eq!(decoded_datalakes.len(), 4);

        assert_eq!(batched_datalakes.encode().unwrap(), batched_block_datalake);
    }

    #[test]
    fn test_transaction_datalakes_encoder() {
        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            100000,
            "tx.nonce".to_string(),
            1,
            100,
            1,
            &[0, 0, 1, 1],
        )
        .unwrap();

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            100000,
            "tx.access_list".to_string(),
            1,
            100,
            1,
            &[0, 0, 1, 1],
        )
        .unwrap();

        let datalakes = vec![
            DatalakeEnvelope::Transactions(transaction_datalake1),
            DatalakeEnvelope::Transactions(transaction_datalake2),
        ];
        let encoded_datalakes = datalakes.encode().unwrap();

        assert_eq!(encoded_datalakes, hex::decode("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000201000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000002010a000000000000000000000000000000000000000000000000000000000000").unwrap());
    }

    #[test]
    fn test_transaction_datalake_decoder() {
        let encoded_datalake = hex::decode("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000201000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000002010a000000000000000000000000000000000000000000000000000000000000").unwrap();
        let decoded_datalake = BatchedDatalakes::decode(&encoded_datalake).unwrap();
        assert_eq!(decoded_datalake.len(), 2);

        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            100000,
            "tx.nonce".to_string(),
            1,
            100,
            1,
            &[0, 0, 1, 1],
        )
        .unwrap();

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            100000,
            "tx.access_list".to_string(),
            1,
            100,
            1,
            &[0, 0, 1, 1],
        )
        .unwrap();

        assert_eq!(
            decoded_datalake[0],
            DatalakeEnvelope::Transactions(transaction_datalake1)
        );
        assert_eq!(
            decoded_datalake[1],
            DatalakeEnvelope::Transactions(transaction_datalake2)
        );
    }

    #[test]
    fn test_transaction_datalakes_encoder_receipt() {
        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            100000,
            "tx_receipt.success".to_string(),
            1,
            100,
            1,
            &[0, 0, 1, 1],
        )
        .unwrap();

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            100000,
            "tx_receipt.bloom".to_string(),
            1,
            100,
            1,
            &[0, 0, 1, 1],
        )
        .unwrap();

        let datalakes = vec![
            DatalakeEnvelope::Transactions(transaction_datalake1),
            DatalakeEnvelope::Transactions(transaction_datalake2),
        ];
        let encoded_datalakes = datalakes.encode().unwrap();

        assert_eq!(encoded_datalakes, hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000202000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000020203000000000000000000000000000000000000000000000000000000000000").unwrap())
    }

    #[test]
    fn test_transaction_datalake_decoder_receipt() {
        let encoded_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000202000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000020203000000000000000000000000000000000000000000000000000000000000").unwrap();
        let decoded_datalake = BatchedDatalakes::decode(&encoded_datalake).unwrap();
        assert_eq!(decoded_datalake.len(), 2);

        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            100000,
            "tx_receipt.success".to_string(),
            1,
            100,
            1,
            &[0, 0, 1, 1],
        )
        .unwrap();

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            100000,
            "tx_receipt.bloom".to_string(),
            1,
            100,
            1,
            &[0, 0, 1, 1],
        )
        .unwrap();

        assert_eq!(
            decoded_datalake[0],
            DatalakeEnvelope::Transactions(transaction_datalake1)
        );
        assert_eq!(
            decoded_datalake[1],
            DatalakeEnvelope::Transactions(transaction_datalake2)
        );
    }
}
