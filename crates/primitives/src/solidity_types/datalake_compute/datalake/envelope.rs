use crate::{
    datalake::{
        block_sampled::BlockSampledDatalake, datalake_type::DatalakeType,
        envelope::DatalakeEnvelope, transactions::TransactionsInBlockDatalake,
    },
    solidity_types::traits::{Codecs, DatalakeCodecs},
    utils::last_byte_to_u8,
};
use alloy::{
    dyn_abi::{DynSolType, DynSolValue},
    primitives::B256,
};
use anyhow::Result;

pub type BatchedDatalakeEnvelope = Vec<DatalakeEnvelope>;

impl Codecs for BatchedDatalakeEnvelope {
    fn encode(&self) -> Result<Vec<u8>> {
        let mut encoded_datalakes: Vec<DynSolValue> = Vec::new();

        for datalake in self {
            let encoded_datalake = match datalake {
                DatalakeEnvelope::BlockSampled(block_sampled_datalake) => {
                    block_sampled_datalake.encode()?
                }
                DatalakeEnvelope::Transactions(transactions_datalake) => {
                    transactions_datalake.encode()?
                }
            };
            encoded_datalakes.push(DynSolValue::Bytes(encoded_datalake));
        }

        let array_encoded_datalakes = DynSolValue::Array(encoded_datalakes);
        let encoded_datalakes = array_encoded_datalakes.abi_encode();
        Ok(encoded_datalakes)
    }

    fn decode(encoded: &[u8]) -> Result<Vec<DatalakeEnvelope>> {
        let datalakes_type: DynSolType = "bytes[]".parse()?;
        let serialized_datalakes = datalakes_type.abi_decode(encoded)?;

        let mut decoded_datalakes = Vec::new();

        if let Some(datalakes) = serialized_datalakes.as_array() {
            for datalake in datalakes {
                let datalake_as_bytes =
                    datalake.as_bytes().expect("Cannot get bytes from datalake");
                decoded_datalakes.push(DatalakeEnvelope::decode(datalake_as_bytes)?);
            }
        }

        Ok(decoded_datalakes)
    }
}

impl DatalakeCodecs for DatalakeEnvelope {
    fn decode(encoded_datalake: &[u8]) -> Result<Self> {
        let datalake_code = last_byte_to_u8(encoded_datalake.chunks(32).next().unwrap());
        let decoded_datalake = match DatalakeType::from_index(datalake_code)? {
            DatalakeType::BlockSampled => {
                DatalakeEnvelope::BlockSampled(BlockSampledDatalake::decode(encoded_datalake)?)
            }
            DatalakeType::TransactionsInBlock => DatalakeEnvelope::Transactions(
                TransactionsInBlockDatalake::decode(encoded_datalake)?,
            ),
        };
        Ok(decoded_datalake)
    }

    fn encode(&self) -> Result<Vec<u8>> {
        match self {
            DatalakeEnvelope::BlockSampled(datalake) => datalake.encode(),
            DatalakeEnvelope::Transactions(datalake) => datalake.encode(),
        }
    }

    fn get_datalake_type(&self) -> DatalakeType {
        match self {
            DatalakeEnvelope::BlockSampled(_) => DatalakeType::BlockSampled,
            DatalakeEnvelope::Transactions(_) => DatalakeType::TransactionsInBlock,
        }
    }

    fn commit(&self) -> B256 {
        match self {
            DatalakeEnvelope::BlockSampled(datalake) => datalake.commit(),
            DatalakeEnvelope::Transactions(datalake) => datalake.commit(),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::datalake::{
        block_sampled::{AccountField, BlockSampledCollection, BlockSampledDatalake, HeaderField},
        envelope::BatchedDatalakes,
        transactions::{IncludedTypes, TransactionsCollection, TransactionsInBlockDatalake},
    };
    use alloy::{hex, primitives::Address};
    use std::str::FromStr;

    use super::*;

    #[test]
    fn test_block_datalake_decoder() {
        let batched_block_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb0f600000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000").unwrap();
        let decoded_datalakes = BatchedDatalakes::decode(&batched_block_datalake).unwrap();

        assert_eq!(decoded_datalakes.len(), 4);
        for datalake in decoded_datalakes.clone() {
            if let DatalakeEnvelope::BlockSampled(block_datalake) = datalake {
                assert_eq!(block_datalake.block_range_start, 10399990);
                assert_eq!(block_datalake.block_range_end, 10400000);
                assert_eq!(
                    block_datalake.sampled_property,
                    BlockSampledCollection::Header(HeaderField::BaseFeePerGas)
                );
                assert_eq!(block_datalake.increment, 1);
            } else {
                panic!("Expected block datalake");
            }
        }

        assert_eq!(decoded_datalakes.encode().unwrap(), batched_block_datalake);
    }

    #[test]
    fn test_block_datalake_decoder_for_account() {
        let batched_block_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004b902400000000000000000000000000000000000000000000000000000000004b9027000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000016020a4de450feb156a2a51ed159b2fb99da26e5f3a30000000000000000000000").unwrap();
        let block_datalake = BlockSampledDatalake::new(
            4952100,
            4952103,
            "account.0x0a4de450feb156a2a51ed159b2fb99da26e5f3a3.nonce"
                .parse()
                .unwrap(),
            1,
        );

        let datalakes = vec![DatalakeEnvelope::BlockSampled(block_datalake.clone())];
        assert_eq!(datalakes.len(), 1);
        for datalake in datalakes.clone() {
            if let DatalakeEnvelope::BlockSampled(block_datalake) = datalake {
                assert_eq!(block_datalake.block_range_start, 4952100);
                assert_eq!(block_datalake.block_range_end, 4952103);
                assert_eq!(
                    block_datalake.sampled_property,
                    BlockSampledCollection::Account(
                        Address::from_str("0x0a4de450feb156a2a51ed159b2fb99da26e5f3a3").unwrap(),
                        AccountField::Nonce
                    )
                );
                assert_eq!(block_datalake.increment, 1);
            } else {
                panic!("Expected block datalake");
            }
        }

        assert_eq!(datalakes.encode().unwrap(), batched_block_datalake);
        assert_eq!(
            BatchedDatalakes::decode(&batched_block_datalake).unwrap(),
            datalakes
        );
    }

    #[test]
    fn test_block_massive_datalake_decoder() {
        let batched_block_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009ead1800000000000000000000000000000000000000000000000000000000009eb100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002010f000000000000000000000000000000000000000000000000000000000000").unwrap();
        let datalake_massive_block = DatalakeEnvelope::BlockSampled(BlockSampledDatalake::new(
            10399000,
            10400000,
            "header.base_fee_per_gas".parse().unwrap(),
            1,
        ));

        let batched_datalakes = vec![
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
            datalake_massive_block.clone(),
        ];
        let decoded_datalakes = BatchedDatalakes::decode(&batched_block_datalake).unwrap();
        assert_eq!(decoded_datalakes.len(), 4);

        assert_eq!(batched_datalakes.encode().unwrap(), batched_block_datalake);
    }

    #[test]
    fn test_transaction_datalakes_encoder() {
        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            100000,
            TransactionsCollection::from_str("tx.nonce").unwrap(),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            100000,
            TransactionsCollection::from_str("tx.access_list").unwrap(),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let datalakes = vec![
            DatalakeEnvelope::Transactions(transaction_datalake1),
            DatalakeEnvelope::Transactions(transaction_datalake2),
        ];
        let encoded_datalakes = datalakes.encode().unwrap();

        assert_eq!(encoded_datalakes, hex::decode("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000201000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000002010a000000000000000000000000000000000000000000000000000000000000").unwrap());
    }

    #[test]
    fn test_transaction_datalake_decoder() {
        let encoded_datalake = hex::decode("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000201000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000002010a000000000000000000000000000000000000000000000000000000000000").unwrap();
        let decoded_datalake = BatchedDatalakes::decode(&encoded_datalake).unwrap();
        assert_eq!(decoded_datalake.len(), 2);

        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            100000,
            TransactionsCollection::from_str("tx.nonce").unwrap(),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            100000,
            TransactionsCollection::from_str("tx.access_list").unwrap(),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        assert_eq!(
            decoded_datalake[0],
            DatalakeEnvelope::Transactions(transaction_datalake1)
        );
        assert_eq!(
            decoded_datalake[1],
            DatalakeEnvelope::Transactions(transaction_datalake2)
        );
    }

    #[test]
    fn test_transaction_datalakes_encoder_receipt() {
        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            100000,
            TransactionsCollection::from_str("tx_receipt.success").unwrap(),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            100000,
            TransactionsCollection::from_str("tx_receipt.bloom").unwrap(),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let datalakes = vec![
            DatalakeEnvelope::Transactions(transaction_datalake1),
            DatalakeEnvelope::Transactions(transaction_datalake2),
        ];
        let encoded_datalakes = datalakes.encode().unwrap();

        assert_eq!(encoded_datalakes, hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000202000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000020203000000000000000000000000000000000000000000000000000000000000").unwrap())
    }

    #[test]
    fn test_transaction_datalake_decoder_receipt() {
        let encoded_datalake = hex::decode("0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000202000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000020203000000000000000000000000000000000000000000000000000000000000").unwrap();
        let decoded_datalake = BatchedDatalakes::decode(&encoded_datalake).unwrap();
        assert_eq!(decoded_datalake.len(), 2);

        let transaction_datalake1 = TransactionsInBlockDatalake::new(
            100000,
            TransactionsCollection::from_str("tx_receipt.success").unwrap(),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        let transaction_datalake2 = TransactionsInBlockDatalake::new(
            100000,
            TransactionsCollection::from_str("tx_receipt.bloom").unwrap(),
            1,
            100,
            1,
            IncludedTypes::from(&[0, 0, 1, 1]),
        );

        assert_eq!(
            decoded_datalake[0],
            DatalakeEnvelope::Transactions(transaction_datalake1)
        );
        assert_eq!(
            decoded_datalake[1],
            DatalakeEnvelope::Transactions(transaction_datalake2)
        );
    }
}
